services:
  # Frontend optimizado para producción
  frontend:
    image: ${REGISTRY:-localhost}/salomon/frontend:prod
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_CONVERSATION_ENGINE_URL=${CONVERSATION_ENGINE_URL:-http://conversation-engine:8002}
      - NEXT_PUBLIC_VOICE_GATEWAY_URL=${VOICE_GATEWAY_URL:-http://voice-gateway:8100}
    networks:
      - salomon-net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      replicas: 2
      update_config:
        order: start-first
        failure_action: rollback
      restart_policy:
        condition: on-failure

  # Backend API optimizada
  core-api:
    image: ${REGISTRY:-localhost}/salomon/core-api:prod
    build:
      context: ./services/core-api
      dockerfile: Dockerfile.prod
    volumes:
      - uploads_volume:/uploads
    environment:
      - NODE_ENV=production
      - JWT_SECRET_FILE=/run/secrets/jwt_secret
      - INTERNAL_API_KEY_FILE=/run/secrets/internal_api_key
    # Sintaxis simplificada para los secrets
    secrets:
      - jwt_secret
      - internal_api_key
    depends_on:
      postgres:
        condition: service_healthy
      kafka:
        condition: service_healthy
    networks:
      - salomon-net
    deploy:
      replicas: 2
      update_config:
        order: start-first
        failure_action: rollback
      restart_policy:
        condition: any
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 512M

  conversation-engine:
    image: ${REGISTRY:-localhost}/salomon/conversation-engine:prod
    build:
      context: ./services/conversation-engine
      dockerfile: Dockerfile
    environment:
      - CORE_API_BASE_URL=http://core-api:3000
    depends_on:
      core-api:
        condition: service_started
    networks:
      - salomon-net
    deploy:
      restart_policy:
        condition: on-failure

  voice-gateway:
    image: ${REGISTRY:-localhost}/salomon/voice-gateway:prod
    build:
      context: ./services/voice-gateway
      dockerfile: Dockerfile
    environment:
      - VOICE_STT_PROVIDER=${VOICE_STT_PROVIDER:-mock}
      - VOICE_TTS_PROVIDER=${VOICE_TTS_PROVIDER:-mock}
    depends_on:
      - conversation-engine
    networks:
      - salomon-net
    deploy:
      restart_policy:
        condition: on-failure

  # Nginx como API Gateway y servidor estático
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/certs:/etc/nginx/certs:ro
    depends_on:
      - frontend
      - core-api
    networks:
      - salomon-net

  # Servicios de observabilidad
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus:/etc/prometheus
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    ports:
      - "9090:9090"
    networks:
      - salomon-net

  grafana:
    image: grafana/grafana
    volumes:
      - grafana_data:/var/lib/grafana
    ports:
      - "3003:3000"
    networks:
      - salomon-net

  # Resto de servicios heredados del docker-compose.yml base

# Definimos los secrets que se usarán en producción
secrets:
  jwt_secret:
    file: ./secrets/jwt_secret.txt
  internal_api_key:
    file: ./secrets/internal_api_key.txt

volumes:
  prometheus_data:
  grafana_data:
  # El resto de volúmenes se heredan del docker-compose.yml base

networks:
  salomon-net:
    driver: overlay # Soporte para swarm mode
