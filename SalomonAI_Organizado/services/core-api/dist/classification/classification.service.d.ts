import { OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Repository } from 'typeorm';
import { ClassifyTransactionDto, TrainTransactionDto, CorrectClassificationDto, ClassificationResultDto } from './dto/transaction.dto';
import { NlpService } from '../nlp/nlp.service';
import { QdrantVectorService } from '../qdrant/qdrant.tokens';
import { KafkaProducerService } from '../kafka/kafka.tokens';
import { ClassificationLabel } from './entities/classification-label.entity';
import { FinancialMovement } from '../financial-movements/entities/financial-movement.entity';
export declare class ClassificationService implements OnModuleInit {
    private readonly nlpService;
    private readonly qdrantService;
    private readonly eventEmitter;
    private readonly kafkaService;
    private readonly configService;
    private readonly labelRepository;
    private readonly movementRepository;
    private readonly logger;
    private readonly COLLECTION_NAME;
    private readonly SIMILARITY_THRESHOLD;
    private readonly MIN_CONFIDENCE_THRESHOLD;
    private readonly BATCH_SIZE;
    private readonly MODEL_VERSION;
    private readonly targetAccuracy;
    private readonly minLabelsForRetraining;
    private readonly retrainingTopic;
    private readonly correctionTopic;
    private totalClassifications;
    private correctPredictions;
    private readonly classificationHistory;
    private readonly classificationCache;
    private readonly maxCacheSize;
    private readonly fallbackRules;
    constructor(nlpService: NlpService, qdrantService: QdrantVectorService, eventEmitter: EventEmitter2, kafkaService: KafkaProducerService, configService: ConfigService, labelRepository: Repository<ClassificationLabel>, movementRepository: Repository<FinancialMovement>);
    private getNumberConfig;
    onModuleInit(): Promise<void>;
    private initializeModel;
    private loadInitialTrainingData;
    classifyTransaction(dto: ClassifyTransactionDto): Promise<ClassificationResultDto>;
    private determineMLClassification;
    private applyAmountBasedAdjustments;
    private determineFallbackClassification;
    trainModel(dto: TrainTransactionDto): Promise<void>;
    correctClassification(dto: CorrectClassificationDto, context?: {
        userId?: string;
    }): Promise<{
        label: ClassificationLabel;
        retrainingQueued: boolean;
        kafkaTopic: string;
        modelVersion: string;
    }>;
    private generateCacheKey;
    private saveToCache;
    private recordClassification;
    private recordCorrection;
    private updateMovementFromCorrection;
    private enqueueCorrectionEvent;
    private enqueueRetrainingBatch;
    performDailyMaintenance(): Promise<void>;
    orchestrateScheduledRetraining(): Promise<void>;
    getModelMetrics(): {
        totalClassifications: number;
        accuracy: number;
        cacheSize: number;
        modelVersion: string;
        collectionName: string;
        recentClassifications: number;
    };
    handleClassificationCorrected(payload: any): Promise<void>;
}
