"""Recommendation engine service for SalomónAI.

The service consumes the artefacts generated by the training engine –
user embeddings stored in Qdrant and rich user context persisted in
PostgreSQL – to build contextualised financial tips. The implementation
remains fully functional even when external infrastructure is missing by
falling back to sensible defaults, which makes it ideal for local
iteration and automated testing.
"""

from __future__ import annotations

import logging
import os
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import uvicorn

try:  # Optional dependency – present only in real deployments
    from qdrant_client import QdrantClient
    from qdrant_client.http import models as qmodels
except Exception:  # pragma: no cover
    QdrantClient = None  # type: ignore
    qmodels = None  # type: ignore

try:
    import psycopg2
    from psycopg2.extras import Json, RealDictCursor
    from psycopg2.pool import SimpleConnectionPool
except Exception:  # pragma: no cover
    psycopg2 = None  # type: ignore
    Json = None  # type: ignore
    RealDictCursor = None  # type: ignore
    SimpleConnectionPool = None  # type: ignore


logger = logging.getLogger("recommendation_engine")
logging.basicConfig(level=logging.INFO)

USER_PROFILE_COLLECTION = "user_financial_profiles"
PROFILE_TABLE = "user_financial_profiles"
FEEDBACK_TABLE = "user_recommendation_feedback"


class TransactionData(BaseModel):
    amount: float
    category: str
    description: Optional[str] = None
    user_id: str
    timestamp: Optional[datetime] = None


class GoalContext(BaseModel):
    goal_id: Optional[str] = None
    description: Optional[str] = None
    target_amount: Optional[float] = None
    current_progress: Optional[float] = None
    due_date: Optional[datetime] = None


class RecommendationResponse(BaseModel):
    recommendation: str
    confidence: float
    category: str
    reasoning: str
    segment: Optional[int] = None
    related_categories: List[str] = Field(default_factory=list)
    goals: List[GoalContext] = Field(default_factory=list)


class FeedbackRequest(BaseModel):
    user_id: str
    recommendation: RecommendationResponse
    feedback: Dict[str, Any] = Field(default_factory=dict)
    transaction: Optional[TransactionData] = None


class HealthResponse(BaseModel):
    status: str
    service: str
    version: str


@dataclass
class UserProfile:
    user_id: str
    feature_vector: List[float]
    cluster_label: Optional[int]
    transaction_summary: Dict[str, Any]
    goal_summary: Dict[str, Any]

    @property
    def goals(self) -> List[Dict[str, Any]]:
        return self.goal_summary.get("goals", [])

    @property
    def top_categories(self) -> List[str]:
        return self.transaction_summary.get("top_categories", [])

    @property
    def average_spent(self) -> float:
        return float(self.transaction_summary.get("average_spent", 0.0))

    @property
    def total_spent(self) -> float:
        return float(self.transaction_summary.get("total_spent", 0.0))


class RecommendationEngineService:
    """Core service that interfaces with storage backends and builds tips."""

    def __init__(
        self,
        postgres_dsn: Optional[str],
        qdrant_url: Optional[str],
        qdrant_api_key: Optional[str],
        collection_name: str = USER_PROFILE_COLLECTION,
    ) -> None:
        self.collection_name = collection_name

        self.qdrant_client: Optional[QdrantClient]
        if qdrant_url and QdrantClient is not None:
            self.qdrant_client = QdrantClient(url=qdrant_url, api_key=qdrant_api_key)
        else:
            self.qdrant_client = None

        if postgres_dsn and psycopg2 is not None and SimpleConnectionPool is not None:
            self.pg_pool = SimpleConnectionPool(1, 5, dsn=postgres_dsn)
        else:
            self.pg_pool = None

    def _get_postgres_profile(self, user_id: str) -> Optional[Dict[str, Any]]:
        if not self.pg_pool:
            return None
        conn = self.pg_pool.getconn()
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(
                    f"""
                    SELECT cluster_label, transaction_summary, goal_summary
                    FROM {PROFILE_TABLE}
                    WHERE user_id = %s
                    """,
                    (user_id,),
                )
                row = cur.fetchone()
                return dict(row) if row else None
        finally:  # pragma: no cover - resource management
            self.pg_pool.putconn(conn)

    def _get_qdrant_profile(self, user_id: str) -> Optional[Dict[str, Any]]:
        if not self.qdrant_client:
            return None
        try:
            points = self.qdrant_client.retrieve(collection_name=self.collection_name, ids=[user_id])
        except Exception as exc:  # pragma: no cover - depends on infra
            logger.error("Failed to retrieve user %s from Qdrant: %s", user_id, exc)
            return None
        if not points:
            return None
        point = points[0]
        return {
            "feature_vector": point.vector or [],
            "cluster_label": point.payload.get("cluster_label") if point.payload else None,
            "transaction_summary": point.payload.get("transaction_summary", {}) if point.payload else {},
            "goal_summary": point.payload.get("goal_summary", {}) if point.payload else {},
        }

    def get_user_profile(self, user_id: str) -> Optional[UserProfile]:
        pg_profile = self._get_postgres_profile(user_id)
        qdrant_profile = self._get_qdrant_profile(user_id)

        if not (pg_profile or qdrant_profile):
            return None

        feature_vector: List[float] = []
        cluster_label: Optional[int] = None
        transaction_summary: Dict[str, Any] = {}
        goal_summary: Dict[str, Any] = {}

        if qdrant_profile:
            feature_vector = qdrant_profile.get("feature_vector", [])
            cluster_label = qdrant_profile.get("cluster_label")
            transaction_summary.update(qdrant_profile.get("transaction_summary", {}))
            goal_summary.update(qdrant_profile.get("goal_summary", {}))

        if pg_profile:
            cluster_label = pg_profile.get("cluster_label") or cluster_label
            transaction_summary.update(pg_profile.get("transaction_summary") or {})
            goal_summary.update(pg_profile.get("goal_summary") or {})

        return UserProfile(
            user_id=user_id,
            feature_vector=feature_vector,
            cluster_label=cluster_label,
            transaction_summary=transaction_summary,
            goal_summary=goal_summary,
        )

    def _heuristic_template(self, transaction: TransactionData, profile: Optional[UserProfile]) -> RecommendationResponse:
        base_confidence = 0.55
        reasoning_parts: List[str] = []
        recommendation = "Transacción analizada. Continúa monitoreando tus finanzas."  # default fallback
        related_categories: List[str] = []

        if profile:
            segment = profile.cluster_label
            avg_spent = profile.average_spent or 0.0
            total_spent = profile.total_spent or 0.0
            goals = [GoalContext(**goal) for goal in profile.goals]
            top_categories = profile.top_categories
        else:
            segment = None
            avg_spent = 0.0
            total_spent = 0.0
            goals = []
            top_categories = []

        amount = transaction.amount

        if amount > (avg_spent * 1.5 if avg_spent else 500):
            recommendation = "Revisa este gasto elevado y compáralo con tu presupuesto." \
                " Considera dividirlo o posponerlo si no es prioritario."
            base_confidence += 0.2
            reasoning_parts.append("Monto detectado por encima de tu promedio")
        elif transaction.category.lower() in {"entretenimiento", "restaurante", "viajes"}:
            recommendation = "Evalúa si este gasto discrecional se alinea con tus metas actuales." \
                " Puedes asignar un límite mensual para mantener el control."
            base_confidence += 0.1
            reasoning_parts.append("Categoría discrecional identificada")
        else:
            recommendation = "La transacción parece coherente con tus hábitos. Sigue monitoreando para mantener el control."
            reasoning_parts.append("No se detectaron anomalías relevantes")

        if goals:
            active_goal = goals[0]
            if active_goal.target_amount and active_goal.current_progress is not None:
                remaining = active_goal.target_amount - active_goal.current_progress
                if remaining > 0:
                    recommendation += f" Recuerda que aún necesitas ahorrar ${remaining:,.0f} para tu objetivo principal."
                    base_confidence += 0.05
                    reasoning_parts.append("Se ajustó a tus metas declaradas")
        elif total_spent and total_spent > 0 and amount > total_spent * 0.2:
            recommendation += " Considera definir un objetivo de ahorro para equilibrar estos gastos."
            reasoning_parts.append("Usuario sin metas activas y gasto representativo")

        if top_categories:
            related_categories = top_categories
            reasoning_parts.append("Contexto personalizado por categorías frecuentes")

        confidence = min(base_confidence, 0.95)
        reasoning = "; ".join(reasoning_parts)

        return RecommendationResponse(
            recommendation=recommendation,
            confidence=round(confidence, 2),
            category=transaction.category,
            reasoning=reasoning,
            segment=segment,
            related_categories=related_categories,
            goals=goals,
        )

    def generate(self, transaction: TransactionData) -> RecommendationResponse:
        profile = self.get_user_profile(transaction.user_id)
        return self._heuristic_template(transaction, profile)

    def store_feedback(self, request: FeedbackRequest) -> None:
        if not self.pg_pool or psycopg2 is None or Json is None:
            logger.info("PostgreSQL not available – feedback stored in logs only")
            logger.info("Feedback payload: %s", request.model_dump())
            return

        conn = self.pg_pool.getconn()
        try:
            with conn.cursor() as cur:
                cur.execute(
                    f"""
                    INSERT INTO {FEEDBACK_TABLE} (id, user_id, recommendation, feedback, transaction_context)
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (
                        os.urandom(16).hex(),
                        request.user_id,
                        Json(request.recommendation.model_dump()),
                        Json(request.feedback),
                        Json(request.transaction.model_dump() if request.transaction else {}),
                    ),
                )
            conn.commit()
        finally:  # pragma: no cover - resource management
            self.pg_pool.putconn(conn)


def get_service() -> RecommendationEngineService:
    return app.state.service  # type: ignore[attr-defined]


app = FastAPI(
    title="SalomónAI - Recommendation Engine",
    description="Motor de recomendaciones financieras inteligentes",
    version="1.1.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("startup")
def _startup() -> None:
    postgres_dsn = os.getenv("POSTGRES_DSN")
    qdrant_url = os.getenv("QDRANT_URL")
    qdrant_api_key = os.getenv("QDRANT_API_KEY")
    app.state.service = RecommendationEngineService(
        postgres_dsn=postgres_dsn,
        qdrant_url=qdrant_url,
        qdrant_api_key=qdrant_api_key,
    )
    logger.info("Recommendation engine initialised")


@app.get("/", response_model=dict)
async def root() -> Dict[str, Any]:
    return {
        "message": "SalomónAI Recommendation Engine",
        "status": "active",
        "version": app.version,
    }


@app.get("/health", response_model=HealthResponse)
async def health_check(service: RecommendationEngineService = Depends(get_service)) -> HealthResponse:
    status_message = "healthy"
    if service.pg_pool is None:
        status_message = "degraded (no Postgres)"
    if service.qdrant_client is None:
        status_message = (
            f"{status_message} & no Qdrant" if status_message != "healthy" else "degraded (no Qdrant)"
        )
    return HealthResponse(status=status_message, service="recommendation-engine", version=app.version)


@app.post("/recommendations", response_model=RecommendationResponse)
async def generate_recommendation(
    transaction: TransactionData,
    service: RecommendationEngineService = Depends(get_service),
) -> RecommendationResponse:
    try:
        return service.generate(transaction)
    except Exception as exc:  # pragma: no cover
        logger.exception("Error generating recommendation")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(exc))


@app.post("/feedback", status_code=status.HTTP_202_ACCEPTED)
async def register_feedback(
    feedback: FeedbackRequest,
    service: RecommendationEngineService = Depends(get_service),
) -> Dict[str, str]:
    service.store_feedback(feedback)
    return {"status": "received"}


@app.get("/recommendations/categories", response_model=List[str])
async def get_supported_categories(service: RecommendationEngineService = Depends(get_service)) -> List[str]:
    profile_categories: List[str] = []
    if service.pg_pool and psycopg2 is not None:
        conn = service.pg_pool.getconn()
        try:
            with conn.cursor() as cur:
                cur.execute(
                    f"""
                    SELECT DISTINCT jsonb_array_elements_text(to_jsonb(transaction_summary->'top_categories'))
                    FROM {PROFILE_TABLE}
                    WHERE transaction_summary ? 'top_categories'
                    """
                )
                profile_categories = [row[0] for row in cur.fetchall() if row and row[0]]
        except Exception as exc:  # pragma: no cover
            logger.error("Failed to fetch categories from Postgres: %s", exc)
        finally:
            service.pg_pool.putconn(conn)

    defaults = [
        "alimentacion",
        "transporte",
        "entretenimiento",
        "salud",
        "educacion",
        "vivienda",
        "servicios",
        "otros",
    ]
    all_categories = sorted(set(defaults + profile_categories))
    return all_categories


if __name__ == "__main__":  # pragma: no cover
    port = int(os.getenv("PORT", 8000))
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True, log_level="info")
